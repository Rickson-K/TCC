<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Quais são as principais etapas iniciais?">
  <title>Portal da Qualidade de Software</title>
  <!-- 
    The MIT License (MIT)

    Copyright (c) 2015 Michał Sajnóg

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    -->
  <link rel="stylesheet" type="text/css" href="css/style-design-de-software.css">
  <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
</head>

<body class="body-design-de-software">
  <header class="cabecalho">
    <nav class="menu-design-de-software" data-aos="fade-down">
      <ul>
        <li><a class="logo"></a></li>
        <li><a href="index.html">Introdução</a></li>
        <li><a>Etapas Iniciais</a>
          <ul>
            <li><a href="especificacao-de-requisitos.html">Especificação de Requisitos</a></li>
            <li><a href="gerenciamento-do-projeto.html">Gerenciamento do Projeto</a></li>
            <li><a href="design-de-software.html">Design de Software</a></li>
          </ul>
        </li>
        <li><a>Etapas de Desenvolvimento</a>
          <ul>
            <li><a href="desenvolvimento-do-codigo.html">Desenvolvimento do Código</a></li>
            <li><a href="gerenciamento-de-mudanca.html">Gerenciamento de Mudança</a></li>
            <li><a href="gerenciamento-de-configuracao.html">Gerenciamento de Configuração</a></li>
            <li><a href="seguranca.html">Segurança</a></li>
            <li><a href="performance.html">Performance</a></li>
            <li><a href="testes.html">Testes</a></li>
          </ul>
        </li>
        <li><a>Etapas Finais</a>
          <ul>
            <li><a href="documentacao.html">Documentação</a></li>
            <li><a href="usabilidade-e-experiencia-do-usuario.html">Usabilidade e Experiência do Usuário</a></li>
            <li><a href="manutenibilidade.html">Manutenibilidade</a></li>
            <li><a href="escalabilidade.html">Escalabilidade</a></li>
            <li><a href="backup-e-recuperacao.html">Backup e Recuperação</a></li>
            <li><a href="compatibilidade.html">Compatibilidade</a></li>
            <li><a href="conformidade-legal-e-regulamentoria.html">Conformidade Legal e Regulatória</a></li>
            <li><a href="monitoramento-e-logs.html">Monitoramento e Logs</a></li>
          </ul>
        </li>
        <li><a href="conclusao.html">Conclusão</a></li>
        <li><a href="sobre.html">Sobre</a></li>
      </ul>
    </nav>
  </header>

  <main class="conteudo">    
    <section class="conteudo-principal">
      <div class="conteudo-principal-escrito">

        <div data-aos="fade-down" align="center">
          <!-- NOME DO SITE -->
          <h1 class="nome-do-site">QUALIDADE DE SOFTWARE</h1>
          <div data-aos="fade-down" class="linha"></div>
        </div>

        <!-- DESIGN DE SOFTWARE -->
        <h1 data-aos="fade-down" class="conteudo-principal-escrito-titulo">=> Design de Software: (MVC, MVVM, DRY, SOLID....).</h1>
        <div data-aos="fade-up" class="conteudo-principal-escrito-subtopico"><p># <strong>Arquitetura adequada</strong>: </p></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;A arquitetura de software representa o projeto de um sistema, referindo-se aos fundamentos estruturais na composição de blocos de software, sendo a disciplina responsável pela organização e comunicação dos elementos essenciais durante a construção de componentes modulares de software.</p></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;Quando construímos um software precisamos descrevê-lo seguindo um plano de execução arquitetural. Nesta etapa, será necessário detalhar como os blocos serão construídos, a forma como sua comunicação será realizada, além de dividir as responsabilidades dos componentes entre as camadas de sua composição.</p></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <div data-aos="fade-up" class="linha"></div><br><br>

        <div data-aos="fade-up" class="conteudo-principal-escrito-subtopico"><p># <strong>Padrões de design (como MVC, MVVM, etc.)</strong>: </p></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;Um padrão de design é uma prática recomendada formalizada que você pode usar para resolver problemas comuns ao projetar um aplicativo ou sistema.</p></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
                
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> MVC </strong>: O padrão de arquitetura MVC foi o primeiro e é popular hoje no mundo das aplicações web. Foi introduzido na década de 1970. Portanto, esse padrãopermite que você crie aplicativos em torno da separação de interesses (SoC). Ele facilita o esforço necessário para testar, manter e desenvolver aplicativos.</strong></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;No padrão MVC, os modelos não entendem visualizações ou controladores. Dessa forma, os observadores de modelo são alertados sempre que as visualizações e os controladores mudam. Então, os controladores ajudam o processo de roteamento a conectar modelos a visualizações relacionadas.</p></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> MVVM </strong>: MVVM é a evolução moderna do MVC. Então, o principal objetivo do MVVM é fornecer uma separação clara entre a lógica de domínio e a camada de apresentação. Portanto, o MVVM oferece suporte à vinculação de dados bidirecional entre exibições e modelos de exibição.</strong></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;O padrão MVVM permite separar a visualização e o modelo do código. Portanto, isso significa que não é necessário quando o modelo altera a visualização e vice-versa. Então, usando um modelo visual, você pode testar a unidade e testar seu comportamento lógico sem envolver a visualização.</p></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> MVP </strong>: O padrão MVP compartilha dois componentes com o MVC: o modelo e a visualização. Então, ele substitui o controlador por um apresentador. Presenter – como o nome sugere – é usado para apresentar algo. Ele permite simular visualizações com mais facilidade.</strong></div>
        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><p>&emsp;&emsp;No MVP, o apresentador tem uma funcionalidade “man-in-the-middle”, pois toda a lógica de apresentação é enviada a ele. Portanto, a visualização e o apresentador no MVP também são independentes um do outro e interagem por meio de uma interface.</p></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <div data-aos="fade-up" class="linha"></div><br><br>

        <div data-aos="fade-up" class="conteudo-principal-escrito-subtopico"><p># <strong>Boas práticas de design (DRY, SOLID, etc.)</strong>: </p></div>

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> DRY (Don't Repeat Yourself) </strong>: O conceito “Don't Repeat Yourself” é um princípio fundamental no desenvolvimento de software que tem em vista evitar a duplicação de código. Ele enfatiza a importância de escrever código conciso, reutilizável e modular, eliminando a necessidade de repetir trechos de código idênticos ou similares em diferentes partes do sistema.<br><br><strong>- Os princípios fundamentais do DRY incluem: </strong></div>
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Reutilização</strong>: O DRY promove a reutilização de código existente em vez de reescrevê-lo repetidamente. Ao criar funções, classes, bibliotecas ou módulos reutilizáveis, é possível chamar essas partes do código sempre que necessário, evitando duplicação e facilitando a manutenção.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Legibilidade</strong>: Evitar repetições desnecessárias torna o código mais legível. Quando o mesmo trecho de código é usado em vários lugares, é mais difícil entender e atualizar o sistema. Ao seguir o DRY, o código se torna mais claro, conciso e fácil de compreender.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Manutenibilidade</strong>: Ao evitar a repetição de código, o DRY simplifica a manutenção do software. Se uma alteração precisa ser feita, ela só precisa ser realizada em um único local, evitando o risco de esquecer de atualizar todas as instâncias duplicadas, o que pode levar a erros e comportamentos indesejados.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Eficiência</strong>: O DRY também promove a eficiência no desenvolvimento de software. Ao reutilizar código, há uma redução do tamanho total do código, resultando em um sistema mais enxuto e economizando tempo e esforço durante o desenvolvimento.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <div data-aos="fade-up" class="linha"></div><br><br>

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> SOLID </strong>: SOLID é um acrônimo para cinco princípios de design de software que foram propostos por Robert C. Martin (também conhecido como Uncle Bob) na década de 1990. Esses princípios tornam o software mais fácil de entender, modificar e manter.<br><br><strong>Confira agora quais são esses 5 princípios e como eles funcionam: </strong></div>
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* S </strong>: Single Responsibility Principle (Princípio da Responsabilidade Única): cada classe ou módulo de software deve ter apenas uma responsabilidade. Isso significa que cada classe deve fazer apenas uma coisa e fazer bem. Se uma classe tiver mais de uma responsabilidade, ela será mais difícil de entender, testar e manter.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* O </strong>: Open-Closed Principle (Princípio Aberto-Fechado): as entidades de software (como classes, módulos ou funções) devem estar abertas para extensão, mas fechadas para modificação. Isso significa que o código existente não deve ser modificado para adicionar novos recursos ou comportamentos. Em vez disso, novos recursos devem ser adicionados por meio de extensões, como herança ou composição.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* L </strong>: Liskov Substitution Principle (Princípio da Substituição de Liskov): objetos de uma classe derivada devem poder ser usados no lugar de objetos de sua classe base sem que o programa seja alterado. Isso significa que as classes derivadas não devem quebrar a funcionalidade da classe base ou introduzir comportamentos inesperados.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* I </strong>: Interface Segregation Principle (Princípio da Segregação de Interface): uma classe não deve ser forçada a depender de interfaces que não usa. Isso significa que você deve criar interfaces específicas para cada responsabilidade da classe, em vez de criar uma única interface que abranja todas as responsabilidades.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* D </strong>: Dependency Inversion Principle (Princípio da Inversão de Dependência): módulos de alto nível não devem depender de módulos de baixo nível. Em vez disso, ambos devem depender de abstrações. Isso significa que você deve depender de interfaces, em vez de implementações concretas.</p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <div data-aos="fade-up" class="linha"></div><br><br>

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> KISS (Keep It Simple, Stupid) </strong>: O princípio KISS é uma filosofia que acredita na genialidade da simplicidade e o “keep it simple” também pode significar manter curto e simples, manter simples e direto, bem como manter inteligente e simples. É um conceito que pode se estender por várias estratégias e segmentos, como marketing, publicidade, branding, conteúdo e até programação.</strong></div>
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O <strong>“keep it simple”</strong> encontra suas origens em conceitos semelhantes, como a navalha de Occam e nas citações de Leonardo da Vinci e Mies Van Der Rohe  que disseram, respectivamente, que a “simplicidade é a sofisticação final” e que “menos é mais”. Entretanto, KISS é um acrônimo para “Keep it simple, stupid” um princípio de design que surgiu na Marinha dos EUA em 1960 – a frase é do engenheiro Kelly Johnson.<br></p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <p data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O princípio KISS afirma que a maioria dos sistemas funciona melhor se eles forem mantidos simples em vez de complicados. Portanto, a simplicidade deve ser um objetivo fundamental no design e a complexidade desnecessária deve ser evitada.<br></p>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
        <div data-aos="fade-up" class="linha"></div><br><br>

        <div data-aos="fade-up" class="conteudo-principal-escrito-texto-topico"><strong><-/> Princípio da Menor Surpresa </strong>: O princípio de menos espanto (ou menos surpresa) sugere que uma solução ou abordagem não surpreenderia uma pessoa razoavelmente experiente na área de assunto quando encontrada pela primeira vez (o público pode variar, por exemplo, usuário final, programador, testador etc.). Em termos mais práticos, o princípio visa alavancar o conhecimento pré-existente dos usuários para minimizar sua curva de aprendizado ao usar um módulo; portanto, qualquer coisa com alto fator de imprevisibilidade é um bom candidato para o redesenho. Aplica-se a todos os aspectos da arquitetura de software: dos serviços de nomeação, à visualização de interfaces do usuário e ao design do modelo de domínio.</strong></div>
        <img data-aos="fade-up" src="../Captura de Tela (23).png" alt="broken" class="video">
      </div>
    </section>
  </main>

  <footer class="rodape-design-de-software">
    <section class="conteudo-rodape-design-de-software">
        <a>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</a>
        <a class="conteudo-rodape-paragrafo1-design-de-software">Portal da Qualidade de Software - <strong>2023&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</strong></a>
        <!-- <a class="conteudo-rodape-paragrafo2-design-de-software" href="#">Creative Commons - (Imagens)</a> -->
    </section>
    <!--<img class="rodape-imagem" src="broken-image.svg" alt="Broken Image">-->
  </footer>
  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
  <script>
      AOS.init({duration: 1200});
  </script>
  <script type="text/javascript" src="scripts.js"></script>
  <script type="text/javascript" src="scroll.js"></script>
  <button id="scrollToTopButton">↑<script type="text/javascript" src="botao.js"></script></button>
</body>
</html>