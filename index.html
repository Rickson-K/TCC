<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="TCC - Qualidade de Software - Fatec Adib Moisés Dib. 2023">
  <title>Trabalho de Conclusão de Curso - Fatec 2023</title>
  <!-- 
    The MIT License (MIT)

    Copyright (c) 2015 Michał Sajnóg

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    -->
  <link rel="stylesheet" type="text/css" href="css/style-index.css">
  <link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
</head>

<body class="body-index">
  <header class="cabecalho">
    <nav class="menu-index" data-aos="fade-down">
      <ul>
        <li><a href="https://fatecsbc.edu.br/2020/" target="_blank">Fatec SBC - 2023</a></li>
        <li><a href="index.html">Página Inicial</a></li>
        <li><a href="sobre.html">Sobre</a></li>
        <li><a href="referencias.html">Referências</a></li>
      </ul>
    </nav>
  </header>

  <main class="conteudo">    
    <section class="conteudo-principal">
      <div class="conteudo-principal-escrito">

        <div data-aos="fade-left" align="center">
          <!-- NOME DO SITE -->
          <h1 class="conteudo-principal-escrito-titulo" id="introducao">PORTAL DA QUALIDADE DE SOFTWARE</h1>
          <div class="linha"></div>
        </div>

        <div data-aos="fade-left" class="conteudo-principal-extendido-escrito-texto">
          <!-- COMO DESENVOLVER UM SOFTWARE COM QUALIDADE? -->
          <h1 id="como-desenvolver-um-software-com-qualidade"><li>COMO DESENVOLVER UM SOFTWARE COM QUALIDADE?</li></h1>
          <p data-aos="fade-up" class="conteudo-principal-escrito-texto">&emsp;&emsp;A concepção e desenvolvimento de um software de alta qualidade demanda a incorporação de uma extensa variedade de práticas e considerações essenciais. A seguir, apresentam-se os principais tópicos que requerem minuciosa abordagem, visando assegurar um produto final de inabalável robustez e confiabilidade:</p>
          
          <div class="linha"></div>
          
          <!-- Especificação de Requisitos -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Especificação de Requisitos:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Elicitação, análise e documentação clara dos requisitos do sistema.<br><br></li></p>
          </div>
          
          <div class="linha"></div>
          
          <!-- Design de Software -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Design de Software:<br><br></li></p>
          </div>

            <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li><strong>Arquitetura adequada</strong>: </li></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;A arquitetura de software representa o projeto de um sistema, referindo-se aos fundamentos estruturais na composição de blocos de software, sendo a disciplina responsável pela organização e comunicação dos elementos essenciais durante a construção de componentes modulares de software.</p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Quando construímos um software precisamos descrevê-lo seguindo um plano de execução arquitetural. Nesta etapa, será necessário detalhar como os blocos serão construídos, a forma como sua comunicação será realizada, além de dividir as responsabilidades dos componentes entre as camadas de sua composição.</p>
              
            <div class="linha"></div><br><br>
            
            <p><li><strong>Padrões de design (como MVC, MVVM, etc.)</strong>: </li></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Um padrão de design é uma prática recomendada formalizada que você pode usar para resolver problemas comuns ao projetar um aplicativo ou sistema.</p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> MVC </strong>: O padrão de arquitetura MVC foi o primeiro e é popular hoje no mundo das aplicações web. Foi introduzido na década de 1970. Portanto, esse padrão permite que você crie aplicativos em torno da separação de interesses (SoC). Ele facilita o esforço necessário para testar, manter e desenvolver aplicativos.</strong></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;No padrão MVC, os modelos não entendem visualizações ou controladores. Dessa forma, os observadores de modelo são alertados sempre que as visualizações e os controladores mudam. Então, os controladores ajudam o processo de roteamento a conectar modelos a visualizações relacionadas.<br></p>
            
            <div class="linha"></div>
            
            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> MVVM </strong>: MVVM é a evolução moderna do MVC. Então, o principal objetivo do MVVM é fornecer uma separação clara entre a lógica de domínio e a camada de apresentação. Portanto, o MVVM oferece suporte à vinculação de dados bidirecional entre exibições e modelos de exibição.</strong></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O padrão MVVM permite separar a visualização e o modelo do código. Portanto, isso significa que não é necessário quando o modelo altera a visualização e vice-versa. Então, usando um modelo visual, você pode testar a unidade e testar seu comportamento lógico sem envolver a visualização.<br></p>

            <div class="linha"></div>

            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> MVP </strong>: O padrão MVP compartilha dois componentes com o MVC: o modelo e a visualização. Então, ele substitui o controlador por um apresentador. Presenter – como o nome sugere – é usado para apresentar algo. Ele permite simular visualizações com mais facilidade.</strong></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;No MVP, o apresentador tem uma funcionalidade “man-in-the-middle”, pois toda a lógica de apresentação é enviada a ele. Portanto, a visualização e o apresentador no MVP também são independentes um do outro e interagem por meio de uma interface.<br></p>

            <div class="linha"></div><br><br>
            
            <p><li><strong>Boas práticas de design (DRY, SOLID, etc.)</strong>: </li></p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> DRY (Don't Repeat Yourself)</strong>: O conceito “Don't Repeat Yourself” é um princípio fundamental no desenvolvimento de software que tem em vista evitar a duplicação de código. Ele enfatiza a importância de escrever código conciso, reutilizável e modular, eliminando a necessidade de repetir trechos de código idênticos ou similares em diferentes partes do sistema.<br><br><strong>- Os princípios fundamentais do DRY incluem: </strong></p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Reutilização</strong>: O DRY promove a reutilização de código existente em vez de reescrevê-lo repetidamente. Ao criar funções, classes, bibliotecas ou módulos reutilizáveis, é possível chamar essas partes do código sempre que necessário, evitando duplicação e facilitando a manutenção.</p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Legibilidade</strong>: Evitar repetições desnecessárias torna o código mais legível. Quando o mesmo trecho de código é usado em vários lugares, é mais difícil entender e atualizar o sistema. Ao seguir o DRY, o código se torna mais claro, conciso e fácil de compreender.</p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Manutenibilidade</strong>: Ao evitar a repetição de código, o DRY simplifica a manutenção do software. Se uma alteração precisa ser feita, ela só precisa ser realizada em um único local, evitando o risco de esquecer de atualizar todas as instâncias duplicadas, o que pode levar a erros e comportamentos indesejados.</p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* Eficiência</strong>: O DRY também promove a eficiência no desenvolvimento de software. Ao reutilizar código, há uma redução do tamanho total do código, resultando em um sistema mais enxuto e economizando tempo e esforço durante o desenvolvimento.</p>
            
            <div class="linha"></div>
            
            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> SOLID</strong>: SOLID é um acrônimo para cinco princípios de design de software que foram propostos por Robert C. Martin (também conhecido como Uncle Bob) na década de 1990. Esses princípios tornam o software mais fácil de entender, modificar e manter.<br><br><strong>Confira agora quais são esses 5 princípios e como eles funcionam:</strong></p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* S - </strong>: Single Responsibility Principle (Princípio da Responsabilidade Única): cada classe ou módulo de software deve ter apenas uma responsabilidade. Isso significa que cada classe deve fazer apenas uma coisa e fazer bem. Se uma classe tiver mais de uma responsabilidade, ela será mais difícil de entender, testar e manter. </p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* O - </strong>: Open-Closed Principle (Princípio Aberto-Fechado): as entidades de software (como classes, módulos ou funções) devem estar abertas para extensão, mas fechadas para modificação. Isso significa que o código existente não deve ser modificado para adicionar novos recursos ou comportamentos. Em vez disso, novos recursos devem ser adicionados por meio de extensões, como herança ou composição. </p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* L - </strong>: Liskov Substitution Principle (Princípio da Substituição de Liskov): objetos de uma classe derivada devem poder ser usados no lugar de objetos de sua classe base sem que o programa seja alterado. Isso significa que as classes derivadas não devem quebrar a funcionalidade da classe base ou introduzir comportamentos inesperados. </p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* I - </strong>: Interface Segregation Principle (Princípio da Segregação de Interface): uma classe não deve ser forçada a depender de interfaces que não usa. Isso significa que você deve criar interfaces específicas para cada responsabilidade da classe, em vez de criar uma única interface que abranja todas as responsabilidades./p>
            <p class="conteudo-principal-escrito-texto-t-t"><strong>&emsp;&emsp;* D - </strong>: Dependency Inversion Principle (Princípio da Inversão de Dependência): módulos de alto nível não devem depender de módulos de baixo nível. Em vez disso, ambos devem depender de abstrações. Isso significa que você deve depender de interfaces, em vez de implementações concretas./p>
            
            <div class="linha"></div>
            
            <p class="conteudo-principal-escrito-texto-t-t"><strong>-> KISS (Keep It Simple, Stupid)</strong>: O princípio KISS é uma filosofia que acredita na genialidade da simplicidade e o “keep it simple” também pode significar manter curto e simples, manter simples e direto, bem como manter inteligente e simples. É um conceito que pode se estender por várias estratégias e segmentos, como marketing, publicidade, branding, conteúdo e até programação.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O <strong>“keep it simple”</strong> encontra suas origens em conceitos semelhantes, como a navalha de Occam e nas citações de Leonardo da Vinci e Mies Van Der Rohe  que disseram, respectivamente, que a “simplicidade é a sofisticação final” e que “menos é mais”. Entretanto, KISS é um acrônimo para “Keep it simple, stupid” um princípio de design que surgiu na Marinha dos EUA em 1960 – a frase é do engenheiro Kelly Johnson.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O princípio KISS afirma que a maioria dos sistemas funciona melhor se eles forem mantidos simples em vez de complicados. Portanto, a simplicidade deve ser um objetivo fundamental no design e a complexidade desnecessária deve ser evitada.<br></p>
            
            <div class="linha"></div>
            
            <p class="conteudo-principal-escrito-texto-t-t"><strong>->Princípio da Menor Surpresa</strong>: O princípio de menos espanto (ou menos surpresa) sugere que uma solução ou abordagem não surpreenderia uma pessoa razoavelmente experiente na área de assunto quando encontrada pela primeira vez (o público pode variar, por exemplo, usuário final, programador, testador etc.). Em termos mais práticos, o princípio visa alavancar o conhecimento pré-existente dos usuários para minimizar sua curva de aprendizado ao usar um módulo; portanto, qualquer coisa com alto fator de imprevisibilidade é um bom candidato para o redesenho. Aplica-se a todos os aspectos da arquitetura de software: dos serviços de nomeação, à visualização de interfaces do usuário e ao design do modelo de domínio.</p>
          </div>

          <div class="linha"></div>

          <!-- Desenvolvimento -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Desenvolvimento:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Programação limpa e legível.<br><br><br><br></li></p>
            <p><li>Uso de boas práticas de codificação: <br><br></li></p>
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Nomenclatura Descritiva</strong>: Uma boa convenção de nomenclatura é essencial para escrever um código legível e compreensível. A escolha adequada de nomes para variáveis, funções, classes e outros elementos do código é fundamental para facilitar a manutenção, colaboração e entendimento do seu programa. Neste artigo, exploraremos as melhores práticas para a convenção de nomenclatura em programação, juntamente com exemplos para ilustrar essas boas práticas.</li></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Clareza e Significado: É importante escolher nomes que sejam claros e expressivos, refletindo o propósito e a função do elemento que estão representando. Evite nomes genéricos como "a" ou "temp" e opte por nomes descritivos que transmitam a intenção do elemento em questão.<br></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Utilize Nomes Coerentes e Abreviações: Mantenha uma consistência na escolha de nomes ao longo do seu código. Isso torna mais fácil para outros desenvolvedores entenderem a lógica do programa, embora abreviações possam economizar espaço, elas podem tornar seu código difícil de entender. Evite abreviações desnecessárias e opte por nomes completos e significativos.<br></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;A convenção de nomenclatura desempenha um papel importante na legibilidade e manutenção do código. Ao seguir as boas práticas de escolha de nomes claros, significativos e coerentes, você facilita a compreensão do seu programa por outros desenvolvedores e melhora a qualidade do código como um todo. Utilize nomes descritivos, evite abreviações obscuras e escolha uma convenção consistente. Lembre-se de que um código bem nomeado é um código mais legível, compreensível e sustentável.<br></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Comentários Adequados</strong>: Comentários são trechos de texto inseridos no código-fonte que não são interpretados pelo compilador ou interpretador, sendo destinados a fornecer explicações e informações adicionais para os programadores que irão ler e manter o código no futuro.</li></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Os comentários ajudam a explicar a lógica por trás de um determinado trecho de código, detalhando a intenção do programador.<br></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Padrão de Indentação</strong>: Padrão de indentação: a indentação consistente ajuda a destacar a estrutura de controle do código, como loops e condicionais. É importante utilizar uma convenção consistente para espaços ou tabulações em todo o código.</li></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Evitar Códigos Duplicados (DRY)</strong>: O princípio DRY ("não se repita") busca reduzir a duplicação de código e os problemas de manutenção resultantes, mas quando é mal aplicado aumenta o acoplamento e atrapalha a leitura do código.</li></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;DRY é uma abreviação para o inglês Don't Repeat Yourself, "Não se Repita". É o primeiro princípio do desenvolvimento de software mencionado por Andy Hunt e Dave Thomas no clássico livro O Programador Pragmático: de aprendiz a mestre. O princípio declara que : “Cada parte do conhecimento deve ter uma representação única, não ambígua e definitva dentro do sistema”.<br></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Nesse contexto, Hunt enfatiza o impacto negativo da duplicação e consequentemente a importância de usar DRY, no wiki do repositório de padrões de Portland: “A duplicação (seja ela acidental ou proposital) pode levar a pesadelos de manutenção, além de atrapalhar a refatoração e gerar contradições lógicas”.<br></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Manter Funções e Métodos Pequenos e Específicos</strong>: Funções e métodos com uma única responsabilidade tendem a ser mais manuteníveis, uma vez que as funções em geral ficam mais propensas à extração de padrões e ao reuso.</li></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O verdadeiro objetivo deve ser realizar uma coisa só, mesmo que essa codificação ocupe um certo número de linhas maior que o esperado , e evita juntar vários comandos  desconexos em uma função só.<br></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Responsabilidade Única</strong>: Como o nome sugere, este princípio afirma que cada classe deve ter uma responsabilidade, um único propósito . Isso significa que uma classe fará apenas um trabalho, o que nos leva a concluir que ela deveria ter apenas um motivo para mudar.</li></p>
              <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Seguindo o princípio SRP, seus métodos e dados estarão preocupados com um propósito claro. Isso significa alta coesão , bem como robustez, que juntas reduzem erros .<br></p>
              
              <div class="linha"></div>

              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Tratamento Adequado de Exceções</strong>: O mecanismo de exceções da linguagem Java fornece uma abordagem simples e organizada para isso. Assim, ao invés de deixarmos o programa terminar devido a situações inesperadas, podemos escrever código para lidar com essas exceções e continuar a execução do programa normalmente. Neste artigo, vamos conhecer as várias categorias de exceções da linguagem Java, aprender a utilizar o mecanismo de exceções que temos disponível para tratá-las, analisar a hierarquia de exceções e entender a importância das informações contidas no stack trace gerado por uma exceção.</li></p>
              
              <div class="linha"></div>
              
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Manter o Código Atualizado com Controle de Versão</strong>: Utilizar sistemas de controle de versão, como Git, para acompanhar as alterações no código e facilitar a colaboração com outros membros da equipe.</li></p>
              
              <div class="linha"></div>
                            
              <p><li class="conteudo-principal-escrito-texto-t-t"><strong>Revisões de Código</strong>: Revisão de código é uma das práticas mais importantes para garantir a saúde a médio e longo prazo da base de código de um sistema. A ideia de revisão de código é simples: todo código desenvolvido por um desenvolvedor tem que ser, em seguida, analisado por pelo menos um outro desenvolvedor, chamado de revisor. O revisor pode adicionar comentários no código sob revisão, procurando esclarecer dúvidas, sugerindo melhorias, indicando bugs, etc.<br></li></p>
            <p><li>Utilização de padrões de codificação (nomenclaturas, formatação, etc.).<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Testes -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Testes: </li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t-t">
            <p><li><strong>Testes unitários</strong>: O Teste Unitário é uma forma de verificar o funcionamento de pequenos pedaços de código, seu principal objetivo é verificar o quão bem seu código está escrito e, caso não esteja funcionando da maneira esperada, permitir que seja corrigido.</li></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Dessa maneira, o teste unitário vem como uma forma mais simples de testagem de códigos, já que não é preciso removê-lo após a testagem, se tornando uma forma diferenciada e eficiente de realizar esse processo tão importante no desenvolvimento de software.<br></p>
            
            <div class="linha"></div><br>
            
            <p><li><strong>Testes de integração</strong>: Teste de integração é quando os módulos (unidades de código) são testados em grupo para garantir que não haja nenhuma quebra naquilo que foi feito unitariamente e naquilo que está sendo integrado.</li></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O cenário ideal é que sejam feitos testes de unidades primeiro e, depois disso, seja feito o teste de integração que busca compreender se os módulos funcionarão juntos.<br></p>
            
            <div class="linha"></div><br>
            
            <p><li><strong>Testes de sistema</strong>: O teste de sistema é realizado após o sistema estar pronto, sendo avaliados todos os componentes e funcionalidades. O objetivo do teste de sistema é exercitar todo o software, assegurando que todos os elementos que compõem o sistema estão de acordo com as especificações dos requisitos, incluindo todos os itens de hardware e software que compõem a regra de negócio.</li></p>
            
            <div class="linha"></div><br>
            
            <p><li><strong>Testes de aceitação do usuário</strong>: Para garantir a aceitação do sistema antes de lançar o produto você pode apresentar uma versão beta a algumas pessoas a fim de realizar últimos ajustes para quando o software for ao mercado tenha êxito real.</li></p>
            
            <div class="linha"></div><br>
            
            <p><li><strong>Testes de regressão</strong>: O teste de regressão é uma técnica de teste de software que consiste na aplicação de versões mais recentes do software, para garantir que não surjam novos defeitos em componentes já comprovados. Se, ao juntar o novo componente ou suas alterações com os componentes restantes do sistema surgirem novos defeitos em componentes inalterados, então considere que o sistema foi corrigido.</li></p>
          </div>

          <div class="linha"></div>

          <!-- Controle de Versão -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Controle de Versão:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t-t-t">
            <p><li><strong>Manter o código atualizado com controle de Versão</strong> : Sistemas de controle de versão são softwares que ajudam a controlar as alterações feitas no código ao longo do tempo. Conforme o desenvolvedor edita o código, o sistema de controle de versão tira um instantâneo dos arquivos. Em seguida, ele salva esse instantâneo permanentemente para que ele possa ser recuperado mais tarde, se necessário.<br><br></li></p>
            <p>&emsp;&emsp;Sem o controle de versão, os desenvolvedores são tentados a manter várias cópias de código em seu computador. Isso é perigoso porque é fácil alterar ou excluir um arquivo na cópia errada do código, potencialmente perdendo trabalho. Os sistemas de controle de versão resolvem esse problema gerenciando todas as versões do código, mas apresentando à equipe uma única versão por vez.<br></p>
          </div>

          <div class="linha"></div>

          <!-- Documentação -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Documentação:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Documentação técnica (como comentários no código, README, etc.).<br><br></li></p>
            <p><li>Documentação do usuário (manuais, guias, tutoriais).<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Gerenciamento de Projeto -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Gerenciamento de Projeto:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Metodologia de desenvolvimento (Scrum, Kanban, etc.).<br><br></li></p>
            <p><li>Ferramentas de gerenciamento de projeto (como Jira, Trello, etc.).<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Gerenciamento de Configuração -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Gerenciamento de Configuração:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Gerenciamento de dependências e bibliotecas.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Segurança -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Segurança:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Proteção contra vulnerabilidades conhecidas.<br><br></li></p>
            <p><li>Boas práticas de segurança (como autenticação e autorização, criptografia, etc.).<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Performance -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Performance:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Otimização de código.<br><br></li></p>
            <p><li>Otimização de consultas em banco de dados.<br><br></li></p>
            <p><li>Monitoramento de desempenho.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Usabilidade e Experiência do Usuário -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Usabilidade e Experiência do Usuário:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Design de interface amigável.<br><br></li></p>
            <p><li>Testes de usabilidade.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Manutenibilidade -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Manutenibilidade:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Facilidade de manter e atualizar o código.<br><br></li></p>
            <p><li>Baixo acoplamento e alta coesão.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Escalabilidade -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Escalabilidade:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Arquitetura escalável para lidar com aumento de carga.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Backup e Recuperação -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Backup e Recuperação:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Estratégias de backup e recuperação de dados.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Compatibilidade -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Compatibilidade:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Testes em diferentes navegadores e dispositivos.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Conformidade Legal e Regulatória -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Conformidade Legal e Regulatória:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p><li>Garantir que o software esteja em conformidade com as leis e regulamentações relevantes.<br><br></li></p>
          </div>

          <div class="linha"></div>

          <!-- Monitoramento e Logs -->
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-d">
            <p><li>Monitoramento e Logs:<br><br></li></p>
          </div>
          <div data-aos="fade-up" class="conteudo-principal-escrito-texto-t">
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;O monitoramento de log é o processo de coleta, análise e ação em dados de log de várias fontes. Isso pode incluir aplicações e infraestrutura — computação, rede e armazenamento. Quando desenvolvedores e equipes operacionais monitoram os logs, eles o fazem para encontrar anomalias e problemas em um sistema e poder solucionar esses problemas da maneira mais eficiente possível.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Para garantir desempenho, disponibilidade e segurança, os logs precisam ser continuamente observados pelos desenvolvedores e equipes de engenharia. Esse processo, comumente conhecido como monitoramento de log, ocorre em tempo real à medida que os logs são registrados.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Juntamente com as métricas e os traces, o monitoramento de log é uma parte importante da observabilidade. O monitoramento de log e um software robusto de gerenciamento de log são essenciais para as empresas porque permitem que as equipes descubram, abordem e resolvam problemas antes que eles afetem os clientes ou outros tipos de usuário.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t"><li><strong>O que são logs?</strong></li><br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Os dados de log são informações geradas por vários sistemas e aplicações à medida que são executados. Esses dados podem incluir eventos do sistema, mensagens de erro, métricas de desempenho e atividade do usuário. Por exemplo, um log pode fornecer um registro de uma falha e a hora em que ela ocorreu, o que permitiria que você encontrasse erros no seu código para solucionar problemas. Cada log recebe um registro de data/hora e mostra um evento que aconteceu em um determinado ponto no tempo.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Os logs podem mostrar eventos que acontecem no sistema operacional, como tentativas de conexão, erros e alterações na configuração. Esses tipos de log são conhecidos como logs do sistema.<br></p>
            <p class="conteudo-principal-escrito-texto-t-t">&emsp;&emsp;Em contraste, os logs de aplicação mostram informações sobre eventos que ocorrem na stack de software de aplicação, especialmente em proxies dedicados, firewalls e outras aplicações. Esses tipos de log registram alterações no software, operações CRUD, autenticação na aplicação e muito mais.<br></p>
          </div>

          <div class="linha"></div>
          
          <p data-aos="fade-up" class="conteudo-principal-escrito-texto">&emsp;&emsp;Ao cumprir de maneira diligente e meticulosa com os pontos delineados acima, é possível assegurar que o software em questão alcance um patamar de excelência em termos de qualidade. A abordagem abrangente que abarca desde a concepção até a implementação e manutenção, seguindo boas práticas e princípios fundamentais do desenvolvimento de software, se traduz em um produto final que atende aos mais elevados padrões da indústria.</p>
          <p data-aos="fade-up" class="conteudo-principal-escrito-texto">&emsp;&emsp;A aplicação de uma arquitetura sólida, aliada a padrões de design consagrados, estabelece as bases para um software robusto e de alta performance. O compromisso com a eficiência, coesão e baixo acoplamento, fundamentados em princípios como DRY e SOLID, resulta em código limpo, facilmente compreensível e passível de manutenção contínua.</p>
          <p data-aos="fade-up" class="conteudo-principal-escrito-texto">&emsp;&emsp;Os testes, por sua vez, desempenham um papel crucial na validação e verificação do software, garantindo que todas as funcionalidades operem conforme o esperado. Desde os testes unitários, que verificam individualmente cada componente, até os testes de aceitação do usuário, que garantem que o software atenda às necessidades reais dos usuários finais, cada etapa contribui para a confiabilidade e confiança no sistema.</p>
          <p data-aos="fade-up" class="conteudo-principal-escrito-texto">&emsp;&emsp;Assim, ao adotar e rigorosamente aplicar esses princípios e práticas, é possível assegurar que o software não apenas atenda, mas supere as expectativas em termos de qualidade e desempenho. A busca pela excelência na engenharia de software não é apenas um objetivo, mas um compromisso que resulta em produtos que não apenas funcionam, mas se destacam na eficácia, confiabilidade e satisfação do usuário.</p>
          <div class="linha"></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
  
        const targetElement = document.querySelector(this.getAttribute('href'));
        const yOffset = -100; // Valor de deslocamento em pixels (ajuste conforme necessário)
  
        const y = targetElement.getBoundingClientRect().top + window.pageYOffset + yOffset;
  
        window.scrollTo({
          top: y,
          behavior: 'smooth'
        });
  
        // Adiciona uma classe temporária para restaurar as margens
        targetElement.classList.add('temp-margin');
  
        // Remove a classe temporária após um curto atraso
        setTimeout(() => {
          targetElement.classList.remove('temp-margin');
        }, 500); // 500 milissegundos (0.5 segundo)
      });
    });
  </script>

  <footer class="rodape-index">
    <section class="conteudo-rodape-index">
        <a>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</a>
        <a class="conteudo-rodape-paragrafo1-index">TCC Fatec Adib Moisés Dib - <strong>2023&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;</strong></a>
        <!-- <a class="conteudo-rodape-paragrafo2-index" href="#">Creative Commons - (Imagens)</a> -->
    </section>
    <!--<img class="rodape-imagem" src="broken-image.svg" alt="Broken Image">-->
  </footer>
  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
  <script>
      AOS.init({duration: 1200});
  </script>
  <script type="text/javascript" src="scripts.js"></script>
  <button id="scrollToTopButton">↑<script type="text/javascript" src="botao.js"></script></button>
</body>
</html>